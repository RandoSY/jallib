

         J A L V 2   D E V I C E   I N C L U D E   F I L E S
         ===================================================
                           Rob Hamerling


 Introduction
 ------------
 When I started with JAL it struck me that there were so few JALV2 include
 files, in particular not for some of my favorite PICmicros (e.g. 16F690,
 12F683). Unfortunately the output of INC2JAL for these chips caused
 compile-time errors with my programs (I understood INC2JAL is not
 up-to-date for JalV2). Having some experience with scanning MPLAB files
 (for my Xwisp2 program) I decided to write a Rexx script to generate
 a set of include files myself!

 The advantages of using a script to generate files are obvious:
  - Create include files for all PICmicros available in MPLAB,
  - with a consistent layout and
  - consistent naming convention and
  - without typing errors.

 The advantages of a standard naming convention are also obvious:
  - Easy migration of a program from one target PICmicro to another.
  - Same applies to libraries using this naming convention.

 This document gives some design and user information about my JalV2 device
 include files. Apart from the .dev files also the .lkr of MPLab are used.



                T H E   O V E R A L L   P I C T U R E
                =====================================

                      +----------+   +-----------+
                      | device   |   |  general  |
                      | specific |---|  include  |
                      | include  |   |ChipDef.jal|
                      +----------+   +-----------+
                           |
           +---------------+---------------+-------------
           |               |               |
     +----------+    +----------+    +----------+    +---
     | function |    | function |    | function |    |
     | include  |    | include  |    | include  |    | etc
     | 'delay'  |    |  'adc'   |    |  'lcd'   |    |
     +----------+    +----------+    +----------+    +---


 General Include (ChipDef.Jal)
 -----------------------------
 The file 'chipdef.jal' which comes with these device include files replaces
 the file with the same name which comes with the compiler distribution.
 It is included by each of the device include files and contains:
 - Constants required by the compiler
 - Commonly used constants for the device include files
 With the statement 'pragma target chip = .....' in every device include
 file the compiler assigns a value to the variable 'target_chip'.
 The program may reference this variable with a symbolic name.  This
 symbolic name consists of 'pic_' followed by the name of the PIC.
 It makes it possible to use the same source file to generate a hex file
 for different types of PICs, as the following example shows:
    include 16f88
    if (target_chip == pic_16f88) then            -- (not for 16F87)
      ADCON0  = 0b0000_0000                       -- disable ADC (digital I/O)
      ANSEL   = 0b0000_0000                       -- all ports digital I/O
      SSPCON1 = 0b0000_0000                       -- disable SPI/I2C
    end if
 By changing the include statement to 16f87 the statements between 'if' and
 'end if' will not be included (the 16F87 doesn't have an ADC module).
 The list of targets in ChipDef.jal makes sure every possible target name
 and the corresponding value of target_chip is known by the compiler.
 Note: The original chipdef.jal file of the compiler package specifies
       different (and not as many) values for 'target_chip' and therefore it
       has to be replaced when using this set of include files.


 Device Include
 --------------
 The device specific include files contain:
 - cpu type (12-, 14- or 16-bits core)
 - program size specification
 - data (EEPROM) location and size specification
 - config and ID memory specification
 - General purpose register (GPR, RAM) location range and sharing
 - Special function register (SFR) address and mirror adresses,
   alias names and bit naming.
 - procedures and functions for shadowing of I/O ports
 - configuration bit declarations


 Function Include
 ----------------
 Function specific include files have to be included by the program
 as required. In most cases these include files require some statements
 to couple function specific registers and pins with the device. See the
 corresponding libraries and accompanying documentation for instructions.



                  U S E R   I N F O R M A T I O N
                  ===============================

 Sample program
 --------------
 The device include files define static device (PICmicro) specific matter.
 This allows writing elementary programs, such as for a blinking LED.
 Device include files are also the base for extensions, such as libraries
 for more complicated functions, such as displaying text on an LCD
 display or handling analog devices.

 Below a simple blink-an-LED program (LED on RA1) for a PIC16F886 using a
 20 MHz resonator. In addition to the device-specific information obtained
 from the include file '16f886.jal' some run-time information is needed,
 like the speed and type of the oscillator and some other 'environmental'
 variables. No extra function libraries are required.

   -- ------ Blink-an-LED on pin A1 of a PIC16F886 --------------------------

   include 16f886                        -- target is a PIC16F886
                                         -- Notes: - The extension .jal is
                                         --          added by the compiler!
                                         --        - No other includes needed.

   pragma target clock 20_000_000        -- oscillator frequency (in Hz)
                                         -- required by _usec_delay

   pragma target OSC         HS          -- high speed external oscillator
   pragma target WDT         Disabled    -- watchdog off
   pragma target PWRTE       Enabled     -- power up timer enabled
   pragma target MCLR        External    -- external chip reset
   pragma target CP          Disabled    -- no code protection
   pragma target CPD         Disabled    -- no data protection
   pragma target BROWNOUT    Enabled     -- brownout reset
   pragma target IESO        Disabled    -- no internal clock switchover
   pragma target FCMEN       Disabled    -- no fail-safe clock monitoring
   pragma target LVP         Disabled    -- no low voltage programming
   pragma target BACKBUG     Disabled    -- no debug
   pragma target VOLTAGE     V40         -- brownout reset at 4.0V
   pragma target WRT         No_Protection -- no write protection

   ANSEL = 0                             -- all pins PortA digital I/O
   C1ON = off                            -- disable comparator C1
   C2ON = off                            -- disable comparator C2

   PORTA = 0                             -- initialise Port A
   PORt_A_DIRECTION = all_output         -- set type of use of the pins
                                         -- PortB and PortC ignored

   var volatile bit LED is pin_A1        -- define alias for pin_A1

   LED = on                              -- there is light!

   forever loop                          -- endless loop
     LED = on                            -- there is light!
     _usec_delay(250000)                 -- spin 1/4 seconds
     LED = off                           -- flip (on->off,off->on)
     _usec_delay(250000)                 -- spin 1/4 seconds
   end loop

 When loaded in a 16F886 with 20 MHz resonator or crystal an LED connected
 (with series resistor!) to pin 3 (RA1) should blink twice a second.

 Note: The statement 'LED = !LED' might cause the infamous Read-Modify-Write
       problem. This problem is avoided by shadowing procedures incorporated
       in the device include files. See section 'About Port Shadowing' below.


 Naming conventions for Ports and Port pins
 ------------------------------------------
 Unfortunately MPLAB of Microchip is not particularly consistent in its
 choice of names! The datasheets and various informational files in MPLAB
 not infrequently use different names for the same entity! Since programmers
 are supposed to read the datasheets, the most obvious would be to use the
 datasheet names, but these are not part of MPLAB and would have to be
 downloaded separately. And these PDF files are not so easily processed with
 a script. So the chosen names are possibly not what you may be used to.

 One - maybe the most important - design decision was that the include files
 must co-operate with as many as possible existing function libraries.
 The most popular 'de facto' standard is Stef Mientki's work.

 For all registers of the chip a name is defined and where appropriate also
 the individual bits are defined.  Some popular aliases for registers are
 defined, for example: TMR0IF and T0IF, TMR0IE and T0IE, etc.

 For all ports and port pins a device independent alias is defined
 and a similar direction definition, as the following examples show:

 For PORTA and TRISA:
   var volatile byte PORTA  at <addr>
   var          byte PORT_A_low                -- low order nibble
   var          byte PORT_A_high               -- high order nibble
   var volatile bit  PIN_A0 at PORTA : 0
   var volatile byte TRISA  at <addr>
   var volatile byte PORT_A_DIRECTION at TRISA
   var volatile bit  PIN_A0_DIRECTION at TRISA : 0
   etc. (for all other existing pins and ports)

 Similarly for GPIO and TRISIO (with the smaller chips):
   var volatile byte GPIO   at <addr>
   var volatile byte PORTA  at GPIO
   var          byte PORT_A_LOW                -- low order nibble
   var          byte PORT_A_HIGH               -- high order nibble
   var volatile bit  PIN_A0 at GPIO : 0
   var volatile byte TRISIO at <addr>
   var volatile byte TRISA  at TRISIO
   var volatile byte PORT_A_DIRECTION at TRISIO
   var volatile bit  PIN_A0_DIRECTION at TRISIO : 0
   etc. (for all other existing pins)

 In addition procedures and functions are defined to read and set the
 lower and upper nibbles of ports and their direction:
   PORT_x_LOW
   PORT_x_HIGH
   PORT_x_LOW_DIRECTION
   PORT_x_HIGH_DIRECTION

 Note: See the extra alias declarations for the GPIO and TRISIO registers
       and their bits. Programs and function libraries can access the GPIO
       bits with Portx and Pin_xy names, allowing easy program migration
       from one PIC to another.


 Duplicate names
 ---------------
 The script tries to avoid duplicate names in the include files. This is
 mainly applicable to subfields of registers (a single bit or a group of
 bits). When the script finds a duplicate name (a name which has already
 been assigned to a variable) it prefixes the second name of the variable
 with the name of the register (the first name may or may not be prefixed!).
 For example: RD16 is a bit in T1CON and T3CON of the PIC18F448.
              The generated names will be T1CON_RD16 and T3CON_RD16.
 Some registers will have all subfields preceeded with the register name.
 This applies mainly to the high-end PIC18Fs with multiple similar function
 modules, like more than one UART or CP modules, etc.  For consistency
 these subfields are even be prefixed with the register name even if the
 particular PICmicro has only 1 of such modules.


 About Port Shadowing
 --------------------
 Port shadowing is a technique to prevent the Read-Modify-Write problem with
 I/O ports of PICmicro's. This is a problem related to its hardware design
 and may occur when a read of a port is immediately followed by writing to
 that port.
 With shadowing a RAM location is used as replacement for the port. Reading
 is done from the port directly. Writing is done to the shadow register and
 then its contents flushed to the real port.

 With these device include files shadowing is automatic, as long as you use
 the following names:
   PORTx          - all bits of port x
   PORT_x_LOW     - low order nibble of port x (bits 3..0)
   PORT_x_HIGH    - high order nibble of port x (bits 7..4)
   PIN_xy         - single bit 'y' of port 'x'
 (in which 'x' is a port-letter and 'y' a bit- or pin-number).

 If you want to use other names for pins or nibbles or the whole port you
 can specify an alias. For example when you have a red LED connected to pin
 0 of PortA, you could specify:

   var volatile bit LED_red is pin_A0

 and use 'LED_red = on' or 'LED_red = off' in your program.

 You should avoid direct pin and I/O port manipulation, because it will be
 overruled by the automatic shadowing mechanism. For example do not specify:

   var volatile bit LED_red at portA : 0

 With this specification a 'LED-red = on' will have the desired result, but
 it will not update the shadow register. Any next operation which uses the
 shadowing mechanism will override the previous direct control operation.

 The shadowing is also bypassed when you initialise the alias with the
 declaration. So declaring and initialising an alias as follows:

   var volatile bit LED_red is pin_A0 = off

 is bad practice!



 Naming convention for configuration bitmasks (fuses)
 ----------------------------------------------------
 The configuration bits or groups of bits is such a large variety that it
 is not easy to have a naming convention which covers it all.
 The following design rules are used:
   - For all implemented config bits a option name and tags are defined,
     but:
      - duplicate option names may be generated
      - duplicate tags may be defined for a single option
      - some of the tags may not be acceptable for the compiler
   - When the compiler stalls over a fuse-def line a manual correction
     should be applied.
   - For the most popular config bits a 'standard' option name is
     defined, along with a 'standard' tag, see the list below.

 Only for the oscillator specification the MPLAB information files contain
 more than 140 different indications!! Because of the synonyms this number
 could be 'normalised' to a much smaller number! The first part is the
 oscillator type, the [optional] second part indicates secundary functions.
 For example it may indicate if the OSC2 pin is CLKOUT or I/O, or if PLL is
 active for the 18F series.
 Other names may appear when the script could not decipher the description
 in the MPLab device file.

 Fuse_Def OSC  (oscillator)
       LP              - Low Power crystal on OSC1,OSC2
       XT              - Crystal or Resonator on OSC1,OSC2
       HS              - High Speed Crystal or Resonator on OSC1,OSC2
       HS_PLL          - as HS + PLL
       HS_USB          - as HS + USB
       EC_CLKOUT       - External Clock (TTL) signal on OSC1, OSC2 is ClockOut
       EC_NOCLKOUT     - External Clock (TTL) signal on OSC1, OSC2 is I/O
       EC_PLL          - as EC + PLL active
       EC_USB          - as EC + USB
       RC_CLKOUT       - RC oscillator on OSC1, OSC2 is ClockOut
       RC_NOCLKOUT     - RC oscillator on OSC1, OSC2 is I/O
       EXTOSC_CLKOUT   - External oscillator on OSC1, ClockOut on OSC2
       EXTOSC_NOCLKOUT - External oscillator on OSC1, OSC2 is I/O
       INTOSC_CLKOUT   - Internal oscillator, OSC1 is I/O, ClockOut on OSC2
       INTOSC_NOCLKOUT - Internal oscillator, OSC1 and OSC2 are I/O
       (some other keywords may be used)

 Fuse_Def WDT  (watchdog)
       ENABLED          - Watchdog enabled
       DISABLED         - Watchdog disabled

 Fuse_Def WDTPS  (Watchdog postscaler)
       P32768           -  1 : 32,768
       P16384           -  1 : 16,384
       P...             -  1 : ...
       P2               -  1 : 2
       P1               -  1 : 1

 Fuse_Def MCLR  (reset)
       EXTERNAL         - /MCLR pin enabled
       INTERNAL         - /MCLR pin is digital I/O

 Fuse_Def PWRTE  (power reset timeout)
       ENABLED          - Power up timer enabled
       DISABLED         - Power Up timer disabled

 Fuse_Def BROWNOUT  (Brown Out detect)
       ENABLED          - BOD enabled, SBOREN disabled
       RUNONLY          - BOD enabled in run, disabled in sleep
       CONTROL          - SBOREN controls BOR function
       DISABLED         - BOD and SBOREN disabled

 Fuse_Def VOLTAGE  (Brownout voltage)
       V20              - 2.0 Volt
       V27              - 2.7 Volt
       V42              - 4.0 Volt
       V45              - 4.5 Volt
       ...  etc (whatever voltages are applicable)

 Fuse_Def LVP  (Low Voltage Programming)
       ENABLED          - LVP on, enabled
       DISABLED         - LVP off, disabled

 Fuse_Def CP  (Code Protection)
       ENABLED          - Code protection on, enabled
       DISABLED         - Code Protection off, disabled

 Fuse_Def CPD  (EEPROM Data Protection)
       ENABLED          - Data Protection on, enabled
       DISABLED         - Data Protection off, disabled

 Notes: 1. In addition to the 'standard' fuse_defs above there may be
           others, depending on the features of the specific PICmicro.
           Please read the include file to see which fuse-defs are
           available for your target PICmicro.
        2. The terms 'Enabled' and 'Disabled' may need to be specified where
           usually 'On' and 'Off' are used.

 When the fuse_def statements cause compile-time error messages you may
 simply delete these and specify the fuse-word(s) or -byte(s) explicitly
 with bit patterns in stead of using fuse option pragma statements.
 For example for the PIC16F690 the following group of statements:

   pragma target OSC       HS
   pragma target WDT       Disabled
   pragma target PWRTE     Enabled
   pragma target MCLR      External
   pragma target CP        Disabled
   pragma target CPD       Disabled
   pragma target BROWNOUT  Enabled
   pragma target IESO      Disabled
   pragma target FCMEN     Disabled

 is equivalent with:

   pragma target fuses   0b11_0011_1110_0010

 PICs with 16-bits core (the 18F series) have such a large variety of
 configuration bits that explicit specification is probably the best way to
 make sure all config bits are set correctly for your program. As an example
 see the following list for a simple blink-a-LED program with an 18F242.

  pragma  target fuses 0  0b0000_0000       -- (n/a)
  pragma  target fuses 1  0b0010_0010       -- not switchable, HS osc, no PLL
  pragma  target fuses 2  0b0000_0001       -- BOR disabled, PWTR disabled
  pragma  target fuses 3  0b0000_0000       -- watchdog disabled
  pragma  target fuses 4  0b0000_0000       -- (n/a)
  pragma  target fuses 5  0b0000_0001       -- CCP2 on RC1
  pragma  target fuses 6  0b1000_0001       -- no bg debug, no LVP, STVREN
  pragma  target fuses 7  0b0000_0000       -- (n/a)
  pragma  target fuses 8  0b0000_1111       -- no code protection
  pragma  target fuses 9  0b1100_0000       -- no data protection
  pragma  target fuses 10 0b0000_1111       -- no code write protection
  pragma  target fuses 11 0b1110_0000       -- no other write protection
  pragma  target fuses 12 0b0000_1111       -- no table read protection
  pragma  target fuses 13 0b0100_0000       -- no boot block write protect

 Notes: - All pragma statements must be specified after the include
          statement of the device file.
        - When a PIC has multiple config words or bytes the index value
          of the word or byte should be specified before the value.

 The meaning of config bits can be found in the DataSheet of the specific
 PICmicro, or in the Programming Specifications. For your convenience the
 MicroChip document numbers are mentioned in the heading of the device
 include files (when present in the MPlab .dev files!).


 Miscellaneous
 -------------

 The use of these device include files may cause problems when used in
 combination with other libraries:

 - Bank switching functions are not needed with JalV2 and do not appear in
   the device includes. This may cause compile-time errors when using
   programs or libraries which still use these procedures. Please remove
   these bank switching functions from your programs or libraries!

 - The device specific include files are generated from the MPLAB .dev and
   .lkr files. This may cause confusion or even conflicts because the
   register and bit names are not always identical to those in the
   datasheets! Apart from that MPLAB is not errorfree, consequently include
   files generated from this source are not guaranteed errorfree too!



