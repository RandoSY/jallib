#summary Using "jallib" wrapper to work with the repository
#labels Phase-Implementation,Phase-QA,Phase-Deploy

This page describes how to install, configure and use the "jallib" wrapper script.

= What is the "jallib" wrapper script ? =

"jallib" script can handle common tasks when working with the SVN repository. Tasks include compiling, validating, registering test results, generating doc, etc... Whether you're a user, a tester or a developper, you may want to have a look at it !


= Installing "jallib" =

The script itself is a python script. It uses several dependencies. You have two options: either you can use the binary executable, or you can install all dependencies.

== All-in-one binary ==

There's currently a windows binary, which embed all these dependencies, including python itself ! If you're able to use this binary (ie. you're under windows, or you have `wine` installed for linux users), this is the fastest way to have "jallib" working. Unfortunately, there's currently only a windows binary.

To make sure it's working for you:

{{{
cd tools
jallib.exe
jallib.exe help
}}}

should inform you about about how to get help.

Under linux, if you can't install dependencies, you may want to try it using `wine`

{{{
cd tools
wine jallib.exe
wine jallib.exe help
}}}


== Installing dependencies ==

The binary distribution drawback is it's slower than using the script the straight way, that is, with all dependencies installed. This is because when you run the binary, it has to uncompress all the content before running it.

So, whether you want it faster or can't use the binary, you have to install dependencies. Don't worry, it's not that complicated...

First, install python 2.5 (it may run with python 2.6):

 * http://www.python.org/download/releases/2.5.2/
   * for linux & others, use your package distrib, or install using sources
   * windows installation is straightforward

Then install Cheetah 2.0.1:

 * http://sourceforge.net/project/showfiles.php?group_id=28961&package_id=20864
   * installation is standard: unpack, and run `python setup.py install` (note, under windows, if python is not in your %PATH%, this should look like `c:\python25\python setup.py install`)

Install YAML 

 * http://pyyaml.org/wiki/PyYAML
   * again, install should be easy, `python setup.py install`

Install wikify library:

 * get the file here: http://cspace.googlecode.com/svn/wiki/wikify.py
   * there's no install script, so do it manually
   * linux: copy the file to `/usr/lib/python2.5/site-packages`
   * windows: copy file to `c:\python25\lib\site-packages`
   * you can also put it in another directory, and use your PYTHONPATH settings (if you don't know what it is, try the former methods)

Finally, install pysvn. This is the trickiest part. You'll need a pysvn library built for SVN >=1.5 (and not SVN 1.4 for instance).

 * http://pysvn.tigris.org/project_downloads.html
   * linux: you can install it using the package distrib (eg. `apt-get install python-svn`), but be sure you have it built against SVN >=1.5. You can of course build it using sources
   * windows: use installation kit. Remember: python2.5 + svn1.5. This is worked for me: http://pysvn.tigris.org/files/documents/1233/43132/py25-pysvn-svn150-1.6.0-975.exe
   * macos: there are also mac os install kits (not tested)
   * if not correctly installed, you'll have an error message saying you can't use this action because the library is not installed. Another error will occur if you did not install the correct version ("client too old").


= Configuring "jallib" =

"jallib" wrapper is highly configurable but you can configure it to use default values. To do this, you can copy/paste one of the following shell script:

 * `tools\jallib.bat` for windows users
 * `tools/jallib.sh` for *nix users

The idea of these script is to configure it according to your installation, ideally put it in your PATH, and that's it, you're ready to use it !

These scripts can handle both the binary or the I-have-installed-all-dependencies way, you just have to comment/uncomment the corresponding chunk of code. Of course, you can modify and put other things in the shell scripts, if it can help you in your everyday jallib tasks :)


= Using "jallib" = 

== Compiling == 

`jallib help compile` will give you details about compiling files with jallib. Basically, once the script is configured, you just have to:

{{{
jallib compile file.jal
}}}

Note: jallib wrapper honors error code status, so if jalv2 compiler returns a code status 1, then the wrapper will do the same.

== Validating ==

`jallib help validate` will give you details about validating files, and checking how compliant they are according to the JallibStyleGuide. Basically:

{{{
jallib validate file.jal [file2.jal ...]
}}}

You can validate multiple files at a time. If all are compliant, it return 0, else if at least has failed, it returns a non-zero code status.

== Testing ==

`jallib help test` for more... This is probably where you can do the most with jallib wrapper. The `test` action is here to help handling test results, for each PIC. The wrapper is able to:

=== Generating or updating a testing matrix (YAML file)=== 

By exploring the sample map and trying to compile tests with board files, to guess which tests are valid for a given PIC. Quite a nice feature :)

{{{
# if JALLIB_MATRIX env var exists, just do
jallib test -u
# or you can specify a file
jallib test -u -f mymatrix.yaml
}}}


=== Working with a PIC subset (small matrix) === 

Because the matrix can be quite big, and because you won't work with all the PIC in the matrix (except Rob who has 250 PICs), you can create a small matrix, dedicated your favorite PIC

{{{
# you have 16f88, 16f877 and 16f877a target chip, so...
jallib test -u -f mysmallmatrix.yaml -n 16f88,16f877,16f877a
}}}

You now have a small matrix, for these PICs only. But remember: only the big fat one have authority. That is, the huge matrix is the only one which is under SVN, is the only which will be considered while generating html files, for instance. So, what to do now ? Merge your small matrix with the big one:

{{{
# if configured, with env vars
jallib test -m mymatrix.yaml
# or, specifying the big matrix file
jallib test -g bigfatmatrix.yaml -m mymatrix.yaml
}}}

Then, you can commit the big matrix file, so everybody knows you've tested things. This feature also allows testers, without svn access, to send their results to the list, then we, developers, integrate results to the main matrix

=== Registering test results ===

Easy...

{{{
# this test is a success 
jallib test -a 16f88:new_test.jal:true
# this one failed
jallib test -a 16f877:new_test.jal:false
}}}

The SVN file revision is important, because it shows where you tested things in the repository. With it, you can precisely track how things are tested, with an history. Fortunately, if you have `pysvn` dependency installed, the wrapper will check extract this information for you, so you don't have to deal with it. If `pysvn` is not installed, you can specify it (and also force it, that is by-passing pysvn):

{{{
jallib test -a 16f628:new_test.jal:true@143
}}}

At any time, you can print the results:

{{{
jallib test -p 16f88
}}}

=== Generating test report (HTML files) ===

Still W.I.P