#summary understanding how the SVN repository is organized...
#labels Phase-QA


= Why having such a structure ? =

_"Yes, why having such a (complicated) structure ?"_ you ask, humble visitor... Current jalv2 compiler version cannot handle include statements in sub-directories, so this is a legitimate question.

We, the jallib team, decided to have such a structure because

 * having files organized helps finding them. Visitors may only want to download a few files, or search for a specific library. *A structured repository helps*.
 * as a developer, as a committer, it's not reasonable to put all files into a single place. That would be a mess. And developers don't like entropy. It also helps classifying things, and when you classify things, you have a better understanding of the overall picture. *A structured repository is mandatory*

_"Yes, but will I have to deal with all these sub-directories ?"_ you then may ask, curious visitor. Two possibilities:

 * you want to live on the cutting edge of jallib, you want to have the very last version of this library. You have to work directly against SVN files. So, yes, you'll have to deal with all thses sub-directories. Fortunately, this [UnixCompilingFromSvnHowto page] can help you getting started with compiling from SVN.

 * the cutting edge is too dangerous for you, you want stable things, validated libs. You want to [http://code.google.com/p/jallib/downloads/list download] a package. In this package, all libraries are put into a single directory, just as usual. See HowtoInstallJallib for more.


= Description =

Now let's dive into this ! 

_Note: what is described here starts from the SVN /trunk._


Just a map, to understand how low/high we are during this trip.

{{{

               ┌────────────────────────────────┐
       high    │            external            │
               ├────────────────┬───────────────┤
        │      │   peripheral   │    jal        │      
               ├────────────────┴───────────────┤
       low     │         device   files         │   
               └────────────────────────────────┘

}}}

== validated/unvalidated ==

First of all, there are two main directories:

 * *validated*: contains all validated files... That is, files in this section have been validated by the jallib team. Some are heavily tested, mainly the core libraries and functionalities. Some have not been tested yet (but you can help !), they have been validated though, as a nice, well-written lib. See the ValidationProcess for more. The validated section acts as a kind of buffer before each release: things are put here, when enough, it's released. Then again, things are put here, etc...

 * *unvalidated*: contains... well, unvalidated libs ! This is where most development is done, where libs are designed, discussed. This is a fast-changing place, be aware !


Both validated and unvalidated structure are supposed to be the same. But, there might be a new structure in unvalidated, which needs to be validated before being including to the validated section.

For the sake of this topic, the following sections describes what you can find with these section, whether *validated* or *unvalidated*


== include/sample ==

 * *include*: contains libraries which can be included. That is, librairies...
 * *sample*: contains _samples_ and _tests_. Each library come with one or more samples. Some important libraries are included in tests. Tests are a special kind of samples, which heavily tests the libraries, tries a lot of combination, etc...


Now, in the followings, we'll talk about structure within the *include* section.

== include ==

=== device ===

Ah... *device* ! Have you ever wondered how many PICs are handled in jallib ? Is your shiny-but-weird PIC supported ? Go here, you'll find the answer, amongst ~300 hundreds of device files (yeah, in unvalidated section...) !

Device files are the very base of every program, you'll find more on this [JallibFileStructure page], section "Device File". Device files are the lower level of jallib, if you want, you can only use them to create your program (but you'll miss the power of all other jallib libraries).

=== peripheral ===

In this directory, you'll find every library used to handle PICs' peripherals. Peripherals is the term Microchip uses to describe PIC's features. These libraries belongs the *core*. It's a higher level than device files, but still low level.

You'll find here everything to play with: *adc*, *comparator*, *data_eeprom*, *flash_memory*, *i2c*, *pwm*, *spi*, *timer*, *usart*.


=== jal ===

*jal* section is quite special. This is not about the compiler, no, it's about _jal language extensions_, that is functionalities you'd like to see as built-ins, implemented into the compiler, for everyday/common usage. These are *core* too. It gets jalv2 even to higher level !

You'll find here libraries to produce *delays*, to *print* and *format* messages, and many more.


=== external ===

This is the highest level... This is where you'll find dedicated librarie for specific parts. It's named *external* because it's about everything that's not internal, that's not within a PIC.

You'll find here libraries to play with *LCDs*, *keyboards*, *motors*, *sensors*, *memory*, etc... 


== sample ==

=== by_device ===

This section contains samples, organized by device. So, go the directory corresponding to your favorite target chip, and you'll find all available samples for this chip. These samples are _ready-to-compile_, so fell free to give a try, it's easy ! If you created a new sample, don't hesitate, *share your shiny new sample to the jallib group, we'll be pleased to add it to the repository*.

=== test ===

In the "test" map, you'll find quite the same hierarchy as in "include". This is where remain test files. Test files are chip independent (there's no "include 16fxxxx"), and perform heavy tests on several important libraries (mainly core libraries, PIC-specific).

So, for instance, in `test/peripheral/usart`, you'll find test dedidated to USART libraries. These tests are mixed up with a "board" file (from "board" directory). A _board_ file and a _test_ file gives a functional, compilable piece of code, which will perform the selected test on the selected target, using the selected board.

"Woah" I hear you say... "What is it such complicated ?" It's not complicated. At least, this apparent complexity avoid code duplication, and permits to seperate the test logic, from the board/target chip setup. Each type of file focus on a specific task. Don't worry about all of this: unless you plan to contribute to jallib as a developper, you won't need all of these. But... we'd be please if you help :)